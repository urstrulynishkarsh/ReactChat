{"ast":null,"code":"'use client';\n\nimport e, { isValidElement as t, useRef as n, useLayoutEffect as o, useEffect as s, cloneElement as a, useSyncExternalStore as r, useState as i } from \"react\";\nimport l from \"clsx\";\nconst c = e => \"number\" == typeof e && !isNaN(e),\n  d = e => \"string\" == typeof e,\n  u = e => \"function\" == typeof e,\n  p = e => d(e) || u(e) ? e : null,\n  m = e => t(e) || d(e) || u(e) || c(e);\nfunction f(e, t, n) {\n  void 0 === n && (n = 300);\n  const {\n    scrollHeight: o,\n    style: s\n  } = e;\n  requestAnimationFrame(() => {\n    s.minHeight = \"initial\", s.height = o + \"px\", s.transition = `all ${n}ms`, requestAnimationFrame(() => {\n      s.height = \"0\", s.padding = \"0\", s.margin = \"0\", setTimeout(t, n);\n    });\n  });\n}\nfunction g(t) {\n  let {\n    enter: a,\n    exit: r,\n    appendPosition: i = !1,\n    collapse: l = !0,\n    collapseDuration: c = 300\n  } = t;\n  return function (t) {\n    let {\n      children: d,\n      position: u,\n      preventExitTransition: p,\n      done: m,\n      nodeRef: g,\n      isIn: y,\n      playToast: v\n    } = t;\n    const h = i ? `${a}--${u}` : a,\n      T = i ? `${r}--${u}` : r,\n      E = n(0);\n    return o(() => {\n      const e = g.current,\n        t = h.split(\" \"),\n        n = o => {\n          o.target === g.current && (v(), e.removeEventListener(\"animationend\", n), e.removeEventListener(\"animationcancel\", n), 0 === E.current && \"animationcancel\" !== o.type && e.classList.remove(...t));\n        };\n      e.classList.add(...t), e.addEventListener(\"animationend\", n), e.addEventListener(\"animationcancel\", n);\n    }, []), s(() => {\n      const e = g.current,\n        t = () => {\n          e.removeEventListener(\"animationend\", t), l ? f(e, m, c) : m();\n        };\n      y || (p ? t() : (E.current = 1, e.className += ` ${T}`, e.addEventListener(\"animationend\", t)));\n    }, [y]), e.createElement(e.Fragment, null, d);\n  };\n}\nfunction y(e, t) {\n  return null != e ? {\n    content: e.content,\n    containerId: e.props.containerId,\n    id: e.props.toastId,\n    theme: e.props.theme,\n    type: e.props.type,\n    data: e.props.data || {},\n    isLoading: e.props.isLoading,\n    icon: e.props.icon,\n    status: t\n  } : {};\n}\nconst v = new Map();\nlet h = [];\nconst T = new Set(),\n  E = e => T.forEach(t => t(e)),\n  b = () => v.size > 0;\nfunction I(e, t) {\n  var n;\n  if (t) return !(null == (n = v.get(t)) || !n.isToastActive(e));\n  let o = !1;\n  return v.forEach(t => {\n    t.isToastActive(e) && (o = !0);\n  }), o;\n}\nfunction _(e, t) {\n  m(e) && (b() || h.push({\n    content: e,\n    options: t\n  }), v.forEach(n => {\n    n.buildToast(e, t);\n  }));\n}\nfunction C(e, t) {\n  v.forEach(n => {\n    null != t && null != t && t.containerId ? (null == t ? void 0 : t.containerId) === n.id && n.toggle(e, null == t ? void 0 : t.id) : n.toggle(e, null == t ? void 0 : t.id);\n  });\n}\nfunction L(e) {\n  const {\n    subscribe: o,\n    getSnapshot: s,\n    setProps: i\n  } = n(function (e) {\n    const n = e.containerId || 1;\n    return {\n      subscribe(o) {\n        const s = function (e, n, o) {\n          let s = 1,\n            r = 0,\n            i = [],\n            l = [],\n            f = [],\n            g = n;\n          const v = new Map(),\n            h = new Set(),\n            T = () => {\n              f = Array.from(v.values()), h.forEach(e => e());\n            },\n            E = e => {\n              l = null == e ? [] : l.filter(t => t !== e), T();\n            },\n            b = e => {\n              const {\n                  toastId: n,\n                  onOpen: s,\n                  updateId: a,\n                  children: r\n                } = e.props,\n                i = null == a;\n              e.staleId && v.delete(e.staleId), v.set(n, e), l = [...l, e.props.toastId].filter(t => t !== e.staleId), T(), o(y(e, i ? \"added\" : \"updated\")), i && u(s) && s(t(r) && r.props);\n            };\n          return {\n            id: e,\n            props: g,\n            observe: e => (h.add(e), () => h.delete(e)),\n            toggle: (e, t) => {\n              v.forEach(n => {\n                null != t && t !== n.props.toastId || u(n.toggle) && n.toggle(e);\n              });\n            },\n            removeToast: E,\n            toasts: v,\n            clearQueue: () => {\n              r -= i.length, i = [];\n            },\n            buildToast: (n, l) => {\n              if ((t => {\n                let {\n                  containerId: n,\n                  toastId: o,\n                  updateId: s\n                } = t;\n                const a = n ? n !== e : 1 !== e,\n                  r = v.has(o) && null == s;\n                return a || r;\n              })(l)) return;\n              const {\n                  toastId: f,\n                  updateId: h,\n                  data: I,\n                  staleId: _,\n                  delay: C\n                } = l,\n                L = () => {\n                  E(f);\n                },\n                N = null == h;\n              N && r++;\n              const $ = {\n                ...g,\n                style: g.toastStyle,\n                key: s++,\n                ...Object.fromEntries(Object.entries(l).filter(e => {\n                  let [t, n] = e;\n                  return null != n;\n                })),\n                toastId: f,\n                updateId: h,\n                data: I,\n                closeToast: L,\n                isIn: !1,\n                className: p(l.className || g.toastClassName),\n                bodyClassName: p(l.bodyClassName || g.bodyClassName),\n                progressClassName: p(l.progressClassName || g.progressClassName),\n                autoClose: !l.isLoading && (w = l.autoClose, k = g.autoClose, !1 === w || c(w) && w > 0 ? w : k),\n                deleteToast() {\n                  const e = v.get(f),\n                    {\n                      onClose: n,\n                      children: s\n                    } = e.props;\n                  u(n) && n(t(s) && s.props), o(y(e, \"removed\")), v.delete(f), r--, r < 0 && (r = 0), i.length > 0 ? b(i.shift()) : T();\n                }\n              };\n              var w, k;\n              $.closeButton = g.closeButton, !1 === l.closeButton || m(l.closeButton) ? $.closeButton = l.closeButton : !0 === l.closeButton && ($.closeButton = !m(g.closeButton) || g.closeButton);\n              let P = n;\n              t(n) && !d(n.type) ? P = a(n, {\n                closeToast: L,\n                toastProps: $,\n                data: I\n              }) : u(n) && (P = n({\n                closeToast: L,\n                toastProps: $,\n                data: I\n              }));\n              const M = {\n                content: P,\n                props: $,\n                staleId: _\n              };\n              g.limit && g.limit > 0 && r > g.limit && N ? i.push(M) : c(C) ? setTimeout(() => {\n                b(M);\n              }, C) : b(M);\n            },\n            setProps(e) {\n              g = e;\n            },\n            setToggle: (e, t) => {\n              v.get(e).toggle = t;\n            },\n            isToastActive: e => l.some(t => t === e),\n            getSnapshot: () => g.newestOnTop ? f.reverse() : f\n          };\n        }(n, e, E);\n        v.set(n, s);\n        const r = s.observe(o);\n        return h.forEach(e => _(e.content, e.options)), h = [], () => {\n          r(), v.delete(n);\n        };\n      },\n      setProps(e) {\n        var t;\n        null == (t = v.get(n)) || t.setProps(e);\n      },\n      getSnapshot() {\n        var e;\n        return null == (e = v.get(n)) ? void 0 : e.getSnapshot();\n      }\n    };\n  }(e)).current;\n  i(e);\n  const l = r(o, s, s);\n  return {\n    getToastToRender: function (e) {\n      if (!l) return [];\n      const t = new Map();\n      return l.forEach(e => {\n        const {\n          position: n\n        } = e.props;\n        t.has(n) || t.set(n, []), t.get(n).push(e);\n      }), Array.from(t, t => e(t[0], t[1]));\n    },\n    isToastActive: I,\n    count: null == l ? void 0 : l.length\n  };\n}\nfunction N(e) {\n  const [t, o] = i(!1),\n    [a, r] = i(!1),\n    l = n(null),\n    c = n({\n      start: 0,\n      delta: 0,\n      removalDistance: 0,\n      canCloseOnClick: !0,\n      canDrag: !1,\n      didMove: !1\n    }).current,\n    {\n      autoClose: d,\n      pauseOnHover: u,\n      closeToast: p,\n      onClick: m,\n      closeOnClick: f\n    } = e;\n  var g, y;\n  function h() {\n    o(!0);\n  }\n  function T() {\n    o(!1);\n  }\n  function E(n) {\n    const o = l.current;\n    c.canDrag && o && (c.didMove = !0, t && T(), c.delta = \"x\" === e.draggableDirection ? n.clientX - c.start : n.clientY - c.start, c.start !== n.clientX && (c.canCloseOnClick = !1), o.style.transform = `translate3d(${\"x\" === e.draggableDirection ? `${c.delta}px, var(--y)` : `0, calc(${c.delta}px + var(--y))`},0)`, o.style.opacity = \"\" + (1 - Math.abs(c.delta / c.removalDistance)));\n  }\n  function b() {\n    document.removeEventListener(\"pointermove\", E), document.removeEventListener(\"pointerup\", b);\n    const t = l.current;\n    if (c.canDrag && c.didMove && t) {\n      if (c.canDrag = !1, Math.abs(c.delta) > c.removalDistance) return r(!0), e.closeToast(), void e.collapseAll();\n      t.style.transition = \"transform 0.2s, opacity 0.2s\", t.style.removeProperty(\"transform\"), t.style.removeProperty(\"opacity\");\n    }\n  }\n  null == (y = v.get((g = {\n    id: e.toastId,\n    containerId: e.containerId,\n    fn: o\n  }).containerId || 1)) || y.setToggle(g.id, g.fn), s(() => {\n    if (e.pauseOnFocusLoss) return document.hasFocus() || T(), window.addEventListener(\"focus\", h), window.addEventListener(\"blur\", T), () => {\n      window.removeEventListener(\"focus\", h), window.removeEventListener(\"blur\", T);\n    };\n  }, [e.pauseOnFocusLoss]);\n  const I = {\n    onPointerDown: function (t) {\n      if (!0 === e.draggable || e.draggable === t.pointerType) {\n        c.didMove = !1, document.addEventListener(\"pointermove\", E), document.addEventListener(\"pointerup\", b);\n        const n = l.current;\n        c.canCloseOnClick = !0, c.canDrag = !0, n.style.transition = \"none\", \"x\" === e.draggableDirection ? (c.start = t.clientX, c.removalDistance = n.offsetWidth * (e.draggablePercent / 100)) : (c.start = t.clientY, c.removalDistance = n.offsetHeight * (80 === e.draggablePercent ? 1.5 * e.draggablePercent : e.draggablePercent) / 100);\n      }\n    },\n    onPointerUp: function (t) {\n      const {\n        top: n,\n        bottom: o,\n        left: s,\n        right: a\n      } = l.current.getBoundingClientRect();\n      \"touchend\" !== t.nativeEvent.type && e.pauseOnHover && t.clientX >= s && t.clientX <= a && t.clientY >= n && t.clientY <= o ? T() : h();\n    }\n  };\n  return d && u && (I.onMouseEnter = T, e.stacked || (I.onMouseLeave = h)), f && (I.onClick = e => {\n    m && m(e), c.canCloseOnClick && p();\n  }), {\n    playToast: h,\n    pauseToast: T,\n    isRunning: t,\n    preventExitTransition: a,\n    toastRef: l,\n    eventHandlers: I\n  };\n}\nfunction $(t) {\n  let {\n    delay: n,\n    isRunning: o,\n    closeToast: s,\n    type: a = \"default\",\n    hide: r,\n    className: i,\n    style: c,\n    controlledProgress: d,\n    progress: p,\n    rtl: m,\n    isIn: f,\n    theme: g\n  } = t;\n  const y = r || d && 0 === p,\n    v = {\n      ...c,\n      animationDuration: `${n}ms`,\n      animationPlayState: o ? \"running\" : \"paused\"\n    };\n  d && (v.transform = `scaleX(${p})`);\n  const h = l(\"Toastify__progress-bar\", d ? \"Toastify__progress-bar--controlled\" : \"Toastify__progress-bar--animated\", `Toastify__progress-bar-theme--${g}`, `Toastify__progress-bar--${a}`, {\n      \"Toastify__progress-bar--rtl\": m\n    }),\n    T = u(i) ? i({\n      rtl: m,\n      type: a,\n      defaultClassName: h\n    }) : l(h, i),\n    E = {\n      [d && p >= 1 ? \"onTransitionEnd\" : \"onAnimationEnd\"]: d && p < 1 ? null : () => {\n        f && s();\n      }\n    };\n  return e.createElement(\"div\", {\n    className: \"Toastify__progress-bar--wrp\",\n    \"data-hidden\": y\n  }, e.createElement(\"div\", {\n    className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${g} Toastify__progress-bar--${a}`\n  }), e.createElement(\"div\", {\n    role: \"progressbar\",\n    \"aria-hidden\": y ? \"true\" : \"false\",\n    \"aria-label\": \"notification timer\",\n    className: T,\n    style: v,\n    ...E\n  }));\n}\nlet w = 1;\nconst k = () => \"\" + w++;\nfunction P(e) {\n  return e && (d(e.toastId) || c(e.toastId)) ? e.toastId : k();\n}\nfunction M(e, t) {\n  return _(e, t), t.toastId;\n}\nfunction x(e, t) {\n  return {\n    ...t,\n    type: t && t.type || e,\n    toastId: P(t)\n  };\n}\nfunction A(e) {\n  return (t, n) => M(t, x(e, n));\n}\nfunction B(e, t) {\n  return M(e, x(\"default\", t));\n}\nB.loading = (e, t) => M(e, x(\"default\", {\n  isLoading: !0,\n  autoClose: !1,\n  closeOnClick: !1,\n  closeButton: !1,\n  draggable: !1,\n  ...t\n})), B.promise = function (e, t, n) {\n  let o,\n    {\n      pending: s,\n      error: a,\n      success: r\n    } = t;\n  s && (o = d(s) ? B.loading(s, n) : B.loading(s.render, {\n    ...n,\n    ...s\n  }));\n  const i = {\n      isLoading: null,\n      autoClose: null,\n      closeOnClick: null,\n      closeButton: null,\n      draggable: null\n    },\n    l = (e, t, s) => {\n      if (null == t) return void B.dismiss(o);\n      const a = {\n          type: e,\n          ...i,\n          ...n,\n          data: s\n        },\n        r = d(t) ? {\n          render: t\n        } : t;\n      return o ? B.update(o, {\n        ...a,\n        ...r\n      }) : B(r.render, {\n        ...a,\n        ...r\n      }), s;\n    },\n    c = u(e) ? e() : e;\n  return c.then(e => l(\"success\", r, e)).catch(e => l(\"error\", a, e)), c;\n}, B.success = A(\"success\"), B.info = A(\"info\"), B.error = A(\"error\"), B.warning = A(\"warning\"), B.warn = B.warning, B.dark = (e, t) => M(e, x(\"default\", {\n  theme: \"dark\",\n  ...t\n})), B.dismiss = function (e) {\n  !function (e) {\n    var t;\n    if (b()) {\n      if (null == e || d(t = e) || c(t)) v.forEach(t => {\n        t.removeToast(e);\n      });else if (e && (\"containerId\" in e || \"id\" in e)) {\n        var n;\n        (null == (n = v.get(e.containerId)) ? void 0 : n.removeToast(e.id)) || v.forEach(t => {\n          t.removeToast(e.id);\n        });\n      }\n    } else h = h.filter(t => null != e && t.options.toastId !== e);\n  }(e);\n}, B.clearWaitingQueue = function (e) {\n  void 0 === e && (e = {}), v.forEach(t => {\n    !t.props.limit || e.containerId && t.id !== e.containerId || t.clearQueue();\n  });\n}, B.isActive = I, B.update = function (e, t) {\n  void 0 === t && (t = {});\n  const n = ((e, t) => {\n    var n;\n    let {\n      containerId: o\n    } = t;\n    return null == (n = v.get(o || 1)) ? void 0 : n.toasts.get(e);\n  })(e, t);\n  if (n) {\n    const {\n        props: o,\n        content: s\n      } = n,\n      a = {\n        delay: 100,\n        ...o,\n        ...t,\n        toastId: t.toastId || e,\n        updateId: k()\n      };\n    a.toastId !== e && (a.staleId = e);\n    const r = a.render || s;\n    delete a.render, M(r, a);\n  }\n}, B.done = e => {\n  B.update(e, {\n    progress: 1\n  });\n}, B.onChange = function (e) {\n  return T.add(e), () => {\n    T.delete(e);\n  };\n}, B.play = e => C(!0, e), B.pause = e => C(!1, e);\nconst O = \"undefined\" != typeof window ? o : s,\n  D = t => {\n    let {\n      theme: n,\n      type: o,\n      isLoading: s,\n      ...a\n    } = t;\n    return e.createElement(\"svg\", {\n      viewBox: \"0 0 24 24\",\n      width: \"100%\",\n      height: \"100%\",\n      fill: \"colored\" === n ? \"currentColor\" : `var(--toastify-icon-color-${o})`,\n      ...a\n    });\n  },\n  z = {\n    info: function (t) {\n      return e.createElement(D, {\n        ...t\n      }, e.createElement(\"path\", {\n        d: \"M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z\"\n      }));\n    },\n    warning: function (t) {\n      return e.createElement(D, {\n        ...t\n      }, e.createElement(\"path\", {\n        d: \"M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z\"\n      }));\n    },\n    success: function (t) {\n      return e.createElement(D, {\n        ...t\n      }, e.createElement(\"path\", {\n        d: \"M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z\"\n      }));\n    },\n    error: function (t) {\n      return e.createElement(D, {\n        ...t\n      }, e.createElement(\"path\", {\n        d: \"M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z\"\n      }));\n    },\n    spinner: function () {\n      return e.createElement(\"div\", {\n        className: \"Toastify__spinner\"\n      });\n    }\n  },\n  R = n => {\n    const {\n        isRunning: o,\n        preventExitTransition: s,\n        toastRef: r,\n        eventHandlers: i,\n        playToast: c\n      } = N(n),\n      {\n        closeButton: d,\n        children: p,\n        autoClose: m,\n        onClick: f,\n        type: g,\n        hideProgressBar: y,\n        closeToast: v,\n        transition: h,\n        position: T,\n        className: E,\n        style: b,\n        bodyClassName: I,\n        bodyStyle: _,\n        progressClassName: C,\n        progressStyle: L,\n        updateId: w,\n        role: k,\n        progress: P,\n        rtl: M,\n        toastId: x,\n        deleteToast: A,\n        isIn: B,\n        isLoading: O,\n        closeOnClick: D,\n        theme: R\n      } = n,\n      S = l(\"Toastify__toast\", `Toastify__toast-theme--${R}`, `Toastify__toast--${g}`, {\n        \"Toastify__toast--rtl\": M\n      }, {\n        \"Toastify__toast--close-on-click\": D\n      }),\n      H = u(E) ? E({\n        rtl: M,\n        position: T,\n        type: g,\n        defaultClassName: S\n      }) : l(S, E),\n      F = function (e) {\n        let {\n            theme: n,\n            type: o,\n            isLoading: s,\n            icon: r\n          } = e,\n          i = null;\n        const l = {\n          theme: n,\n          type: o,\n          isLoading: s\n        };\n        return !1 === r || (u(r) ? i = r(l) : t(r) ? i = a(r, l) : s ? i = z.spinner() : (e => e in z)(o) && (i = z[o](l))), i;\n      }(n),\n      X = !!P || !m,\n      Y = {\n        closeToast: v,\n        type: g,\n        theme: R\n      };\n    let q = null;\n    return !1 === d || (q = u(d) ? d(Y) : t(d) ? a(d, Y) : function (t) {\n      let {\n        closeToast: n,\n        theme: o,\n        ariaLabel: s = \"close\"\n      } = t;\n      return e.createElement(\"button\", {\n        className: `Toastify__close-button Toastify__close-button--${o}`,\n        type: \"button\",\n        onClick: e => {\n          e.stopPropagation(), n(e);\n        },\n        \"aria-label\": s\n      }, e.createElement(\"svg\", {\n        \"aria-hidden\": \"true\",\n        viewBox: \"0 0 14 16\"\n      }, e.createElement(\"path\", {\n        fillRule: \"evenodd\",\n        d: \"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z\"\n      })));\n    }(Y)), e.createElement(h, {\n      isIn: B,\n      done: A,\n      position: T,\n      preventExitTransition: s,\n      nodeRef: r,\n      playToast: c\n    }, e.createElement(\"div\", {\n      id: x,\n      onClick: f,\n      \"data-in\": B,\n      className: H,\n      ...i,\n      style: b,\n      ref: r\n    }, e.createElement(\"div\", {\n      ...(B && {\n        role: k\n      }),\n      className: u(I) ? I({\n        type: g\n      }) : l(\"Toastify__toast-body\", I),\n      style: _\n    }, null != F && e.createElement(\"div\", {\n      className: l(\"Toastify__toast-icon\", {\n        \"Toastify--animate-icon Toastify__zoom-enter\": !O\n      })\n    }, F), e.createElement(\"div\", null, p)), q, e.createElement($, {\n      ...(w && !X ? {\n        key: `pb-${w}`\n      } : {}),\n      rtl: M,\n      theme: R,\n      delay: m,\n      isRunning: o,\n      isIn: B,\n      closeToast: v,\n      hide: y,\n      type: g,\n      style: L,\n      className: C,\n      controlledProgress: X,\n      progress: P || 0\n    })));\n  },\n  S = function (e, t) {\n    return void 0 === t && (t = !1), {\n      enter: `Toastify--animate Toastify__${e}-enter`,\n      exit: `Toastify--animate Toastify__${e}-exit`,\n      appendPosition: t\n    };\n  },\n  H = g(S(\"bounce\", !0)),\n  F = g(S(\"slide\", !0)),\n  X = g(S(\"zoom\")),\n  Y = g(S(\"flip\")),\n  q = {\n    position: \"top-right\",\n    transition: H,\n    autoClose: 5e3,\n    closeButton: !0,\n    pauseOnHover: !0,\n    pauseOnFocusLoss: !0,\n    draggable: \"touch\",\n    draggablePercent: 80,\n    draggableDirection: \"x\",\n    role: \"alert\",\n    theme: \"light\"\n  };\nfunction Q(t) {\n  let o = {\n    ...q,\n    ...t\n  };\n  const s = t.stacked,\n    [a, r] = i(!0),\n    c = n(null),\n    {\n      getToastToRender: d,\n      isToastActive: m,\n      count: f\n    } = L(o),\n    {\n      className: g,\n      style: y,\n      rtl: v,\n      containerId: h\n    } = o;\n  function T(e) {\n    const t = l(\"Toastify__toast-container\", `Toastify__toast-container--${e}`, {\n      \"Toastify__toast-container--rtl\": v\n    });\n    return u(g) ? g({\n      position: e,\n      rtl: v,\n      defaultClassName: t\n    }) : l(t, p(g));\n  }\n  function E() {\n    s && (r(!0), B.play());\n  }\n  return O(() => {\n    if (s) {\n      var e;\n      const t = c.current.querySelectorAll('[data-in=\"true\"]'),\n        n = 12,\n        s = null == (e = o.position) ? void 0 : e.includes(\"top\");\n      let r = 0,\n        i = 0;\n      Array.from(t).reverse().forEach((e, t) => {\n        const o = e;\n        o.classList.add(\"Toastify__toast--stacked\"), t > 0 && (o.dataset.collapsed = `${a}`), o.dataset.pos || (o.dataset.pos = s ? \"top\" : \"bot\");\n        const l = r * (a ? .2 : 1) + (a ? 0 : n * t);\n        o.style.setProperty(\"--y\", `${s ? l : -1 * l}px`), o.style.setProperty(\"--g\", `${n}`), o.style.setProperty(\"--s\", \"\" + (1 - (a ? i : 0))), r += o.offsetHeight, i += .025;\n      });\n    }\n  }, [a, f, s]), e.createElement(\"div\", {\n    ref: c,\n    className: \"Toastify\",\n    id: h,\n    onMouseEnter: () => {\n      s && (r(!1), B.pause());\n    },\n    onMouseLeave: E\n  }, d((t, n) => {\n    const o = n.length ? {\n      ...y\n    } : {\n      ...y,\n      pointerEvents: \"none\"\n    };\n    return e.createElement(\"div\", {\n      className: T(t),\n      style: o,\n      key: `container-${t}`\n    }, n.map(t => {\n      let {\n        content: n,\n        props: o\n      } = t;\n      return e.createElement(R, {\n        ...o,\n        stacked: s,\n        collapseAll: E,\n        isIn: m(o.toastId, o.containerId),\n        style: o.style,\n        key: `toast-${o.key}`\n      }, n);\n    }));\n  }));\n}\nexport { H as Bounce, Y as Flip, z as Icons, F as Slide, Q as ToastContainer, X as Zoom, f as collapseToast, g as cssTransition, B as toast, N as useToast, L as useToastContainer };","map":{"version":3,"names":[],"sources":["/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/utils/propValidator.ts","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/utils/collapseToast.ts","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/utils/cssTransition.tsx","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/utils/mapper.ts","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/core/store.ts","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/hooks/useToastContainer.ts","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/core/containerObserver.ts","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/hooks/useToast.ts","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/components/ProgressBar.tsx","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/core/genToastId.ts","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/core/toast.ts","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/hooks/useIsomorphicLayoutEffect.ts","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/components/Icons.tsx","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/components/Toast.tsx","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/components/CloseButton.tsx","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/components/Transitions.tsx","/Users/nishkarsh/Desktop/ReactChat/node_modules/react-toastify/src/components/ToastContainer.tsx"],"sourcesContent":["import { isValidElement } from 'react';\nimport { Id } from '../types';\n\nexport const isNum = (v: any): v is Number =>\n  typeof v === 'number' && !isNaN(v);\n\nexport const isStr = (v: any): v is String => typeof v === 'string';\n\nexport const isFn = (v: any): v is Function => typeof v === 'function';\n\nexport const isId = (v: unknown): v is Id => isStr(v) || isNum(v);\n\nexport const parseClassName = (v: any) => (isStr(v) || isFn(v) ? v : null);\n\nexport const getAutoCloseDelay = (\n  toastAutoClose?: false | number,\n  containerAutoClose?: false | number\n) =>\n  toastAutoClose === false || (isNum(toastAutoClose) && toastAutoClose > 0)\n    ? toastAutoClose\n    : containerAutoClose;\n\nexport const canBeRendered = <T>(content: T): boolean =>\n  isValidElement(content) || isStr(content) || isFn(content) || isNum(content);\n","import { Default } from './constant';\n\n/**\n * Used to collapse toast after exit animation\n */\nexport function collapseToast(\n  node: HTMLElement,\n  done: () => void,\n  duration = Default.COLLAPSE_DURATION\n) {\n  const { scrollHeight, style } = node;\n\n  requestAnimationFrame(() => {\n    style.minHeight = 'initial';\n    style.height = scrollHeight + 'px';\n    style.transition = `all ${duration}ms`;\n\n    requestAnimationFrame(() => {\n      style.height = '0';\n      style.padding = '0';\n      style.margin = '0';\n      setTimeout(done, duration as number);\n    });\n  });\n}\n","import React, { useEffect, useLayoutEffect, useRef } from 'react';\nimport { collapseToast } from './collapseToast';\nimport { Default } from './constant';\n\nimport { ToastTransitionProps } from '../types';\n\nexport interface CSSTransitionProps {\n  /**\n   * Css class to apply when toast enter\n   */\n  enter: string;\n\n  /**\n   * Css class to apply when toast leave\n   */\n  exit: string;\n\n  /**\n   * Append current toast position to the classname.\n   * If multiple classes are provided, only the last one will get the position\n   * For instance `myclass--top-center`...\n   * `Default: false`\n   */\n  appendPosition?: boolean;\n\n  /**\n   * Collapse toast smoothly when exit animation end\n   * `Default: true`\n   */\n  collapse?: boolean;\n\n  /**\n   * Collapse transition duration\n   * `Default: 300`\n   */\n  collapseDuration?: number;\n}\n\nconst enum AnimationStep {\n  Enter,\n  Exit\n}\n\n/**\n * Css animation that just work.\n * You could use animate.css for instance\n *\n *\n * ```\n * cssTransition({\n *   enter: \"animate__animated animate__bounceIn\",\n *   exit: \"animate__animated animate__bounceOut\"\n * })\n * ```\n *\n */\nexport function cssTransition({\n  enter,\n  exit,\n  appendPosition = false,\n  collapse = true,\n  collapseDuration = Default.COLLAPSE_DURATION\n}: CSSTransitionProps) {\n  return function ToastTransition({\n    children,\n    position,\n    preventExitTransition,\n    done,\n    nodeRef,\n    isIn,\n    playToast\n  }: ToastTransitionProps) {\n    const enterClassName = appendPosition ? `${enter}--${position}` : enter;\n    const exitClassName = appendPosition ? `${exit}--${position}` : exit;\n    const animationStep = useRef(AnimationStep.Enter);\n\n    useLayoutEffect(() => {\n      const node = nodeRef.current!;\n      const classToToken = enterClassName.split(' ');\n\n      const onEntered = (e: AnimationEvent) => {\n        if (e.target !== nodeRef.current) return;\n\n        playToast();\n        node.removeEventListener('animationend', onEntered);\n        node.removeEventListener('animationcancel', onEntered);\n        if (\n          animationStep.current === AnimationStep.Enter &&\n          e.type !== 'animationcancel'\n        ) {\n          node.classList.remove(...classToToken);\n        }\n      };\n\n      const onEnter = () => {\n        node.classList.add(...classToToken);\n        node.addEventListener('animationend', onEntered);\n        node.addEventListener('animationcancel', onEntered);\n      };\n\n      onEnter();\n    }, []);\n\n    useEffect(() => {\n      const node = nodeRef.current!;\n\n      const onExited = () => {\n        node.removeEventListener('animationend', onExited);\n        collapse ? collapseToast(node, done, collapseDuration) : done();\n      };\n\n      const onExit = () => {\n        animationStep.current = AnimationStep.Exit;\n        node.className += ` ${exitClassName}`;\n        node.addEventListener('animationend', onExited);\n      };\n\n      if (!isIn) preventExitTransition ? onExited() : onExit();\n    }, [isIn]);\n\n    return <>{children}</>;\n  };\n}\n","import { Toast, ToastItem, ToastItemStatus } from '../types';\n\nexport function toToastItem(toast: Toast, status: ToastItemStatus): ToastItem {\n  return toast != null\n    ? {\n        content: toast.content,\n        containerId: toast.props.containerId,\n        id: toast.props.toastId,\n        theme: toast.props.theme,\n        type: toast.props.type,\n        data: toast.props.data || {},\n        isLoading: toast.props.isLoading,\n        icon: toast.props.icon,\n        status\n      }\n    : // monkey patch for now\n      ({} as ToastItem);\n}\n","import {\n  Id,\n  NotValidatedToastProps,\n  OnChangeCallback,\n  ToastContainerProps,\n  ToastContent,\n  ToastItem,\n  ToastOptions\n} from '../types';\nimport { Default, canBeRendered, isId } from '../utils';\nimport {\n  ContainerObserver,\n  createContainerObserver\n} from './containerObserver';\n\ninterface EnqueuedToast {\n  content: ToastContent<any>;\n  options: NotValidatedToastProps;\n}\n\ninterface ClearWaitingQueueParams {\n  containerId?: Id;\n}\n\ninterface RemoveParams {\n  id?: Id;\n  containerId: Id;\n}\n\nconst containers = new Map<Id, ContainerObserver>();\nlet renderQueue: EnqueuedToast[] = [];\nconst listeners = new Set<OnChangeCallback>();\n\nconst dispatchChanges = (data: ToastItem) => listeners.forEach(cb => cb(data));\n\nconst hasContainers = () => containers.size > 0;\n\nfunction flushRenderQueue() {\n  renderQueue.forEach(v => pushToast(v.content, v.options));\n  renderQueue = [];\n}\n\nexport const getToast = (id: Id, { containerId }: ToastOptions) =>\n  containers.get(containerId || Default.CONTAINER_ID)?.toasts.get(id);\n\nexport function isToastActive(id: Id, containerId?: Id) {\n  if (containerId) return !!containers.get(containerId)?.isToastActive(id);\n\n  let isActive = false;\n  containers.forEach(c => {\n    if (c.isToastActive(id)) isActive = true;\n  });\n\n  return isActive;\n}\n\nexport function removeToast(params?: Id | RemoveParams) {\n  if (!hasContainers()) {\n    renderQueue = renderQueue.filter(\n      v => params != null && v.options.toastId !== params\n    );\n    return;\n  }\n\n  if (params == null || isId(params)) {\n    containers.forEach(c => {\n      c.removeToast(params as Id);\n    });\n  } else if (params && ('containerId' in params || 'id' in params)) {\n    containers.get(params.containerId)?.removeToast(params.id) ||\n      containers.forEach(c => {\n        c.removeToast(params.id);\n      });\n  }\n}\n\nexport function clearWaitingQueue(p: ClearWaitingQueueParams = {}) {\n  containers.forEach(c => {\n    if (c.props.limit && (!p.containerId || c.id === p.containerId)) {\n      c.clearQueue();\n    }\n  });\n}\n\nexport function pushToast<TData>(\n  content: ToastContent<TData>,\n  options: NotValidatedToastProps\n) {\n  if (!canBeRendered(content)) return;\n  if (!hasContainers()) renderQueue.push({ content, options });\n\n  containers.forEach(c => {\n    c.buildToast(content, options);\n  });\n}\n\ninterface ToggleToastParams {\n  id?: Id;\n  containerId?: Id;\n}\n\ntype RegisterToggleOpts = {\n  id: Id;\n  containerId?: Id;\n  fn: (v: boolean) => void;\n};\n\nexport function registerToggle(opts: RegisterToggleOpts) {\n  containers\n    .get(opts.containerId || Default.CONTAINER_ID)\n    ?.setToggle(opts.id, opts.fn);\n}\n\nexport function toggleToast(v: boolean, opt?: ToggleToastParams) {\n  containers.forEach(c => {\n    if (opt == null || !opt?.containerId) {\n      c.toggle(v, opt?.id);\n    } else if (opt?.containerId === c.id) {\n      c.toggle(v, opt?.id);\n    }\n  });\n}\n\nexport function registerContainer(props: ToastContainerProps) {\n  const id = props.containerId || Default.CONTAINER_ID;\n  return {\n    subscribe(notify: () => void) {\n      const container = createContainerObserver(id, props, dispatchChanges);\n\n      containers.set(id, container);\n      const unobserve = container.observe(notify);\n      flushRenderQueue();\n\n      return () => {\n        unobserve();\n        containers.delete(id);\n      };\n    },\n    setProps(p: ToastContainerProps) {\n      containers.get(id)?.setProps(p);\n    },\n    getSnapshot() {\n      return containers.get(id)?.getSnapshot();\n    }\n  };\n}\n\nexport function onChange(cb: OnChangeCallback) {\n  listeners.add(cb);\n\n  return () => {\n    listeners.delete(cb);\n  };\n}\n","import { useRef, useSyncExternalStore } from 'react';\nimport { isToastActive, registerContainer } from '../core/store';\nimport { Toast, ToastContainerProps, ToastPosition } from '../types';\n\nexport function useToastContainer(props: ToastContainerProps) {\n  const { subscribe, getSnapshot, setProps } = useRef(\n    registerContainer(props)\n  ).current;\n  setProps(props);\n  const snapshot = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n\n  function getToastToRender<T>(\n    cb: (position: ToastPosition, toastList: Toast[]) => T\n  ) {\n    if (!snapshot) return [];\n\n    const toRender = new Map<ToastPosition, Toast[]>();\n\n    snapshot.forEach(toast => {\n      const { position } = toast.props;\n      toRender.has(position) || toRender.set(position, []);\n      toRender.get(position)!.push(toast);\n    });\n\n    return Array.from(toRender, p => cb(p[0], p[1]));\n  }\n\n  return {\n    getToastToRender,\n    isToastActive,\n    count: snapshot?.length\n  };\n}\n","import { ReactElement, cloneElement, isValidElement } from 'react';\nimport {\n  Id,\n  NotValidatedToastProps,\n  OnChangeCallback,\n  Toast,\n  ToastContainerProps,\n  ToastContent,\n  ToastProps\n} from '../types';\nimport {\n  canBeRendered,\n  getAutoCloseDelay,\n  isFn,\n  isNum,\n  isStr,\n  parseClassName,\n  toToastItem\n} from '../utils';\n\ninterface QueuedToast {\n  content: ToastContent<any>;\n  props: ToastProps;\n  staleId?: Id;\n}\n\ntype Notify = () => void;\n\ninterface ActiveToast {\n  content: ToastContent<any>;\n  props: ToastProps;\n  staleId?: Id;\n}\n\nexport type ContainerObserver = ReturnType<typeof createContainerObserver>;\n\nexport function createContainerObserver(\n  id: Id,\n  containerProps: ToastContainerProps,\n  dispatchChanges: OnChangeCallback\n) {\n  let toastKey = 1;\n  let toastCount = 0;\n  let queue: QueuedToast[] = [];\n  let activeToasts: Id[] = [];\n  let snapshot: Toast[] = [];\n  let props = containerProps;\n  const toasts = new Map<Id, Toast>();\n  const listeners = new Set<Notify>();\n\n  const observe = (notify: Notify) => {\n    listeners.add(notify);\n    return () => listeners.delete(notify);\n  };\n\n  const notify = () => {\n    snapshot = Array.from(toasts.values());\n    listeners.forEach(cb => cb());\n  };\n\n  const shouldIgnoreToast = ({\n    containerId,\n    toastId,\n    updateId\n  }: NotValidatedToastProps) => {\n    const containerMismatch = containerId ? containerId !== id : id !== 1;\n    const isDuplicate = toasts.has(toastId) && updateId == null;\n\n    return containerMismatch || isDuplicate;\n  };\n\n  const toggle = (v: boolean, id?: Id) => {\n    toasts.forEach(t => {\n      if (id == null || id === t.props.toastId) isFn(t.toggle) && t.toggle(v);\n    });\n  };\n\n  const removeToast = (id?: Id) => {\n    activeToasts = id == null ? [] : activeToasts.filter(v => v !== id);\n    notify();\n  };\n\n  const clearQueue = () => {\n    toastCount -= queue.length;\n    queue = [];\n  };\n\n  const addActiveToast = (toast: ActiveToast) => {\n    const { toastId, onOpen, updateId, children } = toast.props;\n    const isNew = updateId == null;\n\n    if (toast.staleId) toasts.delete(toast.staleId);\n\n    toasts.set(toastId, toast);\n    activeToasts = [...activeToasts, toast.props.toastId].filter(\n      v => v !== toast.staleId\n    );\n    notify();\n    dispatchChanges(toToastItem(toast, isNew ? 'added' : 'updated'));\n\n    if (isNew && isFn(onOpen))\n      onOpen(isValidElement(children) && children.props);\n  };\n\n  const buildToast = <TData = unknown>(\n    content: ToastContent<TData>,\n    options: NotValidatedToastProps\n  ) => {\n    if (shouldIgnoreToast(options)) return;\n\n    const { toastId, updateId, data, staleId, delay } = options;\n    const closeToast = () => {\n      removeToast(toastId);\n    };\n\n    const isNotAnUpdate = updateId == null;\n\n    if (isNotAnUpdate) toastCount++;\n\n    const toastProps = {\n      ...props,\n      style: props.toastStyle,\n      key: toastKey++,\n      ...Object.fromEntries(\n        Object.entries(options).filter(([_, v]) => v != null)\n      ),\n      toastId,\n      updateId,\n      data,\n      closeToast,\n      isIn: false,\n      className: parseClassName(options.className || props.toastClassName),\n      bodyClassName: parseClassName(\n        options.bodyClassName || props.bodyClassName\n      ),\n      progressClassName: parseClassName(\n        options.progressClassName || props.progressClassName\n      ),\n      autoClose: options.isLoading\n        ? false\n        : getAutoCloseDelay(options.autoClose, props.autoClose),\n      deleteToast() {\n        const toastToRemove = toasts.get(toastId)!;\n        const { onClose, children } = toastToRemove.props;\n        if (isFn(onClose)) onClose(isValidElement(children) && children.props);\n\n        dispatchChanges(toToastItem(toastToRemove, 'removed'));\n        toasts.delete(toastId);\n\n        toastCount--;\n        if (toastCount < 0) toastCount = 0;\n\n        if (queue.length > 0) {\n          addActiveToast(queue.shift() as ActiveToast);\n          return;\n        }\n\n        notify();\n      }\n    } as ToastProps;\n\n    toastProps.closeButton = props.closeButton;\n\n    if (options.closeButton === false || canBeRendered(options.closeButton)) {\n      toastProps.closeButton = options.closeButton;\n    } else if (options.closeButton === true) {\n      toastProps.closeButton = canBeRendered(props.closeButton)\n        ? props.closeButton\n        : true;\n    }\n\n    let toastContent = content;\n\n    if (isValidElement(content) && !isStr(content.type)) {\n      toastContent = cloneElement(content as ReactElement, {\n        closeToast,\n        toastProps,\n        data\n      });\n    } else if (isFn(content)) {\n      toastContent = content({ closeToast, toastProps, data: data as TData });\n    }\n\n    const activeToast = {\n      content: toastContent,\n      props: toastProps,\n      staleId\n    };\n\n    // not handling limit + delay by design. Waiting for user feedback first\n    if (\n      props.limit &&\n      props.limit > 0 &&\n      toastCount > props.limit &&\n      isNotAnUpdate\n    ) {\n      queue.push(activeToast);\n    } else if (isNum(delay)) {\n      setTimeout(() => {\n        addActiveToast(activeToast);\n      }, delay);\n    } else {\n      addActiveToast(activeToast);\n    }\n  };\n\n  return {\n    id,\n    props,\n    observe,\n    toggle,\n    removeToast,\n    toasts,\n    clearQueue,\n    buildToast,\n    setProps(p: ToastContainerProps) {\n      props = p;\n    },\n    setToggle: (id: Id, fn: (v: boolean) => void) => {\n      toasts.get(id)!.toggle = fn;\n    },\n    isToastActive: (id: Id) => activeToasts.some(v => v === id),\n    getSnapshot: () => (props.newestOnTop ? snapshot.reverse() : snapshot)\n  };\n}\n","import { DOMAttributes, useEffect, useRef, useState } from 'react';\n\nimport { ToastProps } from '../types';\nimport { Default, Direction } from '../utils';\nimport { registerToggle } from '../core/store';\n\ninterface Draggable {\n  start: number;\n  delta: number;\n  removalDistance: number;\n  canCloseOnClick: boolean;\n  canDrag: boolean;\n  didMove: boolean;\n}\n\nexport function useToast(props: ToastProps) {\n  const [isRunning, setIsRunning] = useState(false);\n  const [preventExitTransition, setPreventExitTransition] = useState(false);\n  const toastRef = useRef<HTMLDivElement>(null);\n  const drag = useRef<Draggable>({\n    start: 0,\n    delta: 0,\n    removalDistance: 0,\n    canCloseOnClick: true,\n    canDrag: false,\n    didMove: false\n  }).current;\n  const { autoClose, pauseOnHover, closeToast, onClick, closeOnClick } = props;\n\n  registerToggle({\n    id: props.toastId,\n    containerId: props.containerId,\n    fn: setIsRunning\n  });\n\n  useEffect(() => {\n    if (props.pauseOnFocusLoss) {\n      bindFocusEvents();\n\n      return () => {\n        unbindFocusEvents();\n      };\n    }\n  }, [props.pauseOnFocusLoss]);\n\n  function bindFocusEvents() {\n    if (!document.hasFocus()) pauseToast();\n\n    window.addEventListener('focus', playToast);\n    window.addEventListener('blur', pauseToast);\n  }\n\n  function unbindFocusEvents() {\n    window.removeEventListener('focus', playToast);\n    window.removeEventListener('blur', pauseToast);\n  }\n\n  function onDragStart(e: React.PointerEvent<HTMLElement>) {\n    if (props.draggable === true || props.draggable === e.pointerType) {\n      bindDragEvents();\n      const toast = toastRef.current!;\n      drag.canCloseOnClick = true;\n      drag.canDrag = true;\n      toast.style.transition = 'none';\n\n      if (props.draggableDirection === Direction.X) {\n        drag.start = e.clientX;\n        drag.removalDistance =\n          toast.offsetWidth * (props.draggablePercent / 100);\n      } else {\n        drag.start = e.clientY;\n        drag.removalDistance =\n          (toast.offsetHeight *\n            (props.draggablePercent === Default.DRAGGABLE_PERCENT\n              ? props.draggablePercent * 1.5\n              : props.draggablePercent)) /\n          100;\n      }\n    }\n  }\n\n  function onDragTransitionEnd(e: React.PointerEvent<HTMLElement>) {\n    const { top, bottom, left, right } =\n      toastRef.current!.getBoundingClientRect();\n\n    if (\n      e.nativeEvent.type !== 'touchend' &&\n      props.pauseOnHover &&\n      e.clientX >= left &&\n      e.clientX <= right &&\n      e.clientY >= top &&\n      e.clientY <= bottom\n    ) {\n      pauseToast();\n    } else {\n      playToast();\n    }\n  }\n\n  function playToast() {\n    setIsRunning(true);\n  }\n\n  function pauseToast() {\n    setIsRunning(false);\n  }\n\n  function bindDragEvents() {\n    drag.didMove = false;\n    document.addEventListener('pointermove', onDragMove);\n    document.addEventListener('pointerup', onDragEnd);\n  }\n\n  function unbindDragEvents() {\n    document.removeEventListener('pointermove', onDragMove);\n    document.removeEventListener('pointerup', onDragEnd);\n  }\n\n  function onDragMove(e: PointerEvent) {\n    const toast = toastRef.current!;\n    if (drag.canDrag && toast) {\n      drag.didMove = true;\n      if (isRunning) pauseToast();\n      if (props.draggableDirection === Direction.X) {\n        drag.delta = e.clientX - drag.start;\n      } else {\n        drag.delta = e.clientY - drag.start;\n      }\n\n      // prevent false positive during a toast click\n      if (drag.start !== e.clientX) drag.canCloseOnClick = false;\n      const translate =\n        props.draggableDirection === 'x'\n          ? `${drag.delta}px, var(--y)`\n          : `0, calc(${drag.delta}px + var(--y))`;\n      toast.style.transform = `translate3d(${translate},0)`;\n      toast.style.opacity = `${\n        1 - Math.abs(drag.delta / drag.removalDistance)\n      }`;\n    }\n  }\n\n  function onDragEnd() {\n    unbindDragEvents();\n    const toast = toastRef.current!;\n    if (drag.canDrag && drag.didMove && toast) {\n      drag.canDrag = false;\n      if (Math.abs(drag.delta) > drag.removalDistance) {\n        setPreventExitTransition(true);\n        props.closeToast();\n        props.collapseAll();\n        return;\n      }\n\n      toast.style.transition = 'transform 0.2s, opacity 0.2s';\n      toast.style.removeProperty('transform');\n      toast.style.removeProperty('opacity');\n    }\n  }\n\n  const eventHandlers: DOMAttributes<HTMLElement> = {\n    onPointerDown: onDragStart,\n    onPointerUp: onDragTransitionEnd\n  };\n\n  if (autoClose && pauseOnHover) {\n    eventHandlers.onMouseEnter = pauseToast;\n\n    // progress control is delegated to the container\n    if (!props.stacked) eventHandlers.onMouseLeave = playToast;\n  }\n\n  // prevent toast from closing when user drags the toast\n  if (closeOnClick) {\n    eventHandlers.onClick = (e: React.MouseEvent) => {\n      onClick && onClick(e);\n      drag.canCloseOnClick && closeToast();\n    };\n  }\n\n  return {\n    playToast,\n    pauseToast,\n    isRunning,\n    preventExitTransition,\n    toastRef,\n    eventHandlers\n  };\n}\n","import React from 'react';\nimport cx from 'clsx';\n\nimport { Default, isFn, Type } from './../utils';\nimport { TypeOptions, ToastClassName, Theme } from '../types';\n\nexport interface ProgressBarProps {\n  /**\n   * The animation delay which determine when to close the toast\n   */\n  delay: number;\n\n  /**\n   * Whether or not the animation is running or paused\n   */\n  isRunning: boolean;\n\n  /**\n   * Func to close the current toast\n   */\n  closeToast: () => void;\n\n  /**\n   * Optional type : info, success ...\n   */\n  type?: TypeOptions;\n\n  /**\n   * The theme that is currently used\n   */\n  theme: Theme;\n\n  /**\n   * Hide or not the progress bar\n   */\n  hide?: boolean;\n\n  /**\n   * Optional className\n   */\n  className?: ToastClassName;\n\n  /**\n   * Optional inline style\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * Tell wether or not controlled progress bar is used\n   */\n  controlledProgress?: boolean;\n\n  /**\n   * Controlled progress value\n   */\n  progress?: number | string;\n\n  /**\n   * Support rtl content\n   */\n  rtl?: boolean;\n\n  /**\n   * Tell if the component is visible on screen or not\n   */\n  isIn?: boolean;\n}\n\nexport function ProgressBar({\n  delay,\n  isRunning,\n  closeToast,\n  type = Type.DEFAULT,\n  hide,\n  className,\n  style: userStyle,\n  controlledProgress,\n  progress,\n  rtl,\n  isIn,\n  theme\n}: ProgressBarProps) {\n  const isHidden = hide || (controlledProgress && progress === 0);\n  const style: React.CSSProperties = {\n    ...userStyle,\n    animationDuration: `${delay}ms`,\n    animationPlayState: isRunning ? 'running' : 'paused'\n  };\n\n  if (controlledProgress) style.transform = `scaleX(${progress})`;\n  const defaultClassName = cx(\n    `${Default.CSS_NAMESPACE}__progress-bar`,\n    controlledProgress\n      ? `${Default.CSS_NAMESPACE}__progress-bar--controlled`\n      : `${Default.CSS_NAMESPACE}__progress-bar--animated`,\n    `${Default.CSS_NAMESPACE}__progress-bar-theme--${theme}`,\n    `${Default.CSS_NAMESPACE}__progress-bar--${type}`,\n    {\n      [`${Default.CSS_NAMESPACE}__progress-bar--rtl`]: rtl\n    }\n  );\n  const classNames = isFn(className)\n    ? className({\n        rtl,\n        type,\n        defaultClassName\n      })\n    : cx(defaultClassName, className);\n\n  // ðŸ§ controlledProgress is derived from progress\n  // so if controlledProgress is set\n  // it means that this is also the case for progress\n  const animationEvent = {\n    [controlledProgress && (progress as number)! >= 1\n      ? 'onTransitionEnd'\n      : 'onAnimationEnd']:\n      controlledProgress && (progress as number)! < 1\n        ? null\n        : () => {\n            isIn && closeToast();\n          }\n  };\n\n  // TODO: add aria-valuenow, aria-valuemax, aria-valuemin\n\n  return (\n    <div\n      className={`${Default.CSS_NAMESPACE}__progress-bar--wrp`}\n      data-hidden={isHidden}\n    >\n      <div\n        className={`${Default.CSS_NAMESPACE}__progress-bar--bg ${Default.CSS_NAMESPACE}__progress-bar-theme--${theme} ${Default.CSS_NAMESPACE}__progress-bar--${type}`}\n      />\n      <div\n        role=\"progressbar\"\n        aria-hidden={isHidden ? 'true' : 'false'}\n        aria-label=\"notification timer\"\n        className={classNames}\n        style={style}\n        {...animationEvent}\n      />\n    </div>\n  );\n}\n","let TOAST_ID = 1;\n\nexport const genToastId = () => `${TOAST_ID++}`;\n","import {\n  Id,\n  IdOpts,\n  NotValidatedToastProps,\n  ToastContent,\n  ToastOptions,\n  ToastProps,\n  TypeOptions,\n  UpdateOptions\n} from '../types';\nimport { Type, isFn, isNum, isStr } from '../utils';\nimport { genToastId } from './genToastId';\nimport {\n  clearWaitingQueue,\n  getToast,\n  isToastActive,\n  onChange,\n  pushToast,\n  removeToast,\n  toggleToast\n} from './store';\n\n/**\n * Generate a toastId or use the one provided\n */\nfunction getToastId<TData>(options?: ToastOptions<TData>) {\n  return options && (isStr(options.toastId) || isNum(options.toastId))\n    ? options.toastId\n    : genToastId();\n}\n\n/**\n * If the container is not mounted, the toast is enqueued\n */\nfunction dispatchToast<TData>(\n  content: ToastContent<TData>,\n  options: NotValidatedToastProps\n): Id {\n  pushToast(content, options);\n  return options.toastId;\n}\n\n/**\n * Merge provided options with the defaults settings and generate the toastId\n */\nfunction mergeOptions<TData>(type: string, options?: ToastOptions<TData>) {\n  return {\n    ...options,\n    type: (options && options.type) || type,\n    toastId: getToastId(options)\n  } as NotValidatedToastProps;\n}\n\nfunction createToastByType(type: string) {\n  return <TData = unknown>(\n    content: ToastContent<TData>,\n    options?: ToastOptions<TData>\n  ) => dispatchToast(content, mergeOptions(type, options));\n}\n\nfunction toast<TData = unknown>(\n  content: ToastContent<TData>,\n  options?: ToastOptions<TData>\n) {\n  return dispatchToast(content, mergeOptions(Type.DEFAULT, options));\n}\n\ntoast.loading = <TData = unknown>(\n  content: ToastContent<TData>,\n  options?: ToastOptions<TData>\n) =>\n  dispatchToast(\n    content,\n    mergeOptions(Type.DEFAULT, {\n      isLoading: true,\n      autoClose: false,\n      closeOnClick: false,\n      closeButton: false,\n      draggable: false,\n      ...options\n    })\n  );\n\nexport interface ToastPromiseParams<\n  TData = unknown,\n  TError = unknown,\n  TPending = unknown\n> {\n  pending?: string | UpdateOptions<TPending>;\n  success?: string | UpdateOptions<TData>;\n  error?: string | UpdateOptions<TError>;\n}\n\nfunction handlePromise<TData = unknown, TError = unknown, TPending = unknown>(\n  promise: Promise<TData> | (() => Promise<TData>),\n  { pending, error, success }: ToastPromiseParams<TData, TError, TPending>,\n  options?: ToastOptions<TData>\n) {\n  let id: Id;\n\n  if (pending) {\n    id = isStr(pending)\n      ? toast.loading(pending, options)\n      : toast.loading(pending.render, {\n          ...options,\n          ...(pending as ToastOptions)\n        } as ToastOptions<TPending>);\n  }\n\n  const resetParams = {\n    isLoading: null,\n    autoClose: null,\n    closeOnClick: null,\n    closeButton: null,\n    draggable: null\n  };\n\n  const resolver = <T>(\n    type: TypeOptions,\n    input: string | UpdateOptions<T> | undefined,\n    result: T\n  ) => {\n    // Remove the toast if the input has not been provided. This prevents the toast from hanging\n    // in the pending state if a success/error toast has not been provided.\n    if (input == null) {\n      toast.dismiss(id);\n      return;\n    }\n\n    const baseParams = {\n      type,\n      ...resetParams,\n      ...options,\n      data: result\n    };\n    const params = isStr(input) ? { render: input } : input;\n\n    // if the id is set we know that it's an update\n    if (id) {\n      toast.update(id, {\n        ...baseParams,\n        ...params\n      } as UpdateOptions);\n    } else {\n      // using toast.promise without loading\n      toast(params!.render, {\n        ...baseParams,\n        ...params\n      } as ToastOptions<T>);\n    }\n\n    return result;\n  };\n\n  const p = isFn(promise) ? promise() : promise;\n\n  //call the resolvers only when needed\n  p.then(result => resolver('success', success, result)).catch(err =>\n    resolver('error', error, err)\n  );\n\n  return p;\n}\n\n/**\n * Supply a promise or a function that return a promise and the notification will be updated if it resolves or fails.\n * When the promise is pending a spinner is displayed by default.\n * `toast.promise` returns the provided promise so you can chain it.\n *\n * Simple example:\n *\n * ```\n * toast.promise(MyPromise,\n *  {\n *    pending: 'Promise is pending',\n *    success: 'Promise resolved ðŸ‘Œ',\n *    error: 'Promise rejected ðŸ¤¯'\n *  }\n * )\n *\n * ```\n *\n * Advanced usage:\n * ```\n * toast.promise<{name: string}, {message: string}, undefined>(\n *    resolveWithSomeData,\n *    {\n *      pending: {\n *        render: () => \"I'm loading\",\n *        icon: false,\n *      },\n *      success: {\n *        render: ({data}) => `Hello ${data.name}`,\n *        icon: \"ðŸŸ¢\",\n *      },\n *      error: {\n *        render({data}){\n *          // When the promise reject, data will contains the error\n *          return <MyErrorComponent message={data.message} />\n *        }\n *      }\n *    }\n * )\n * ```\n */\ntoast.promise = handlePromise;\ntoast.success = createToastByType(Type.SUCCESS);\ntoast.info = createToastByType(Type.INFO);\ntoast.error = createToastByType(Type.ERROR);\ntoast.warning = createToastByType(Type.WARNING);\ntoast.warn = toast.warning;\ntoast.dark = (content: ToastContent, options?: ToastOptions) =>\n  dispatchToast(\n    content,\n    mergeOptions(Type.DEFAULT, {\n      theme: 'dark',\n      ...options\n    })\n  );\n\ninterface RemoveParams {\n  id?: Id;\n  containerId: Id;\n}\n\nfunction dismiss(params: RemoveParams): void;\nfunction dismiss(params?: Id): void;\nfunction dismiss(params?: Id | RemoveParams) {\n  removeToast(params);\n}\n\n/**\n * Remove toast programmatically\n *\n * - Remove all toasts:\n * ```\n * toast.dismiss()\n * ```\n *\n * - Remove all toasts that belongs to a given container\n * ```\n * toast.dismiss({ container: \"123\" })\n * ```\n *\n * - Remove toast that has a given id regardless the container\n * ```\n * toast.dismiss({ id: \"123\" })\n * ```\n *\n * - Remove toast that has a given id for a specific container\n * ```\n * toast.dismiss({ id: \"123\", containerId: \"12\" })\n * ```\n */\ntoast.dismiss = dismiss;\n\n/**\n * Clear waiting queue when limit is used\n */\ntoast.clearWaitingQueue = clearWaitingQueue;\n\n/**\n * Check if a toast is active\n *\n * - Check regardless the container\n * ```\n * toast.isActive(\"123\")\n * ```\n *\n * - Check in a specific container\n * ```\n * toast.isActive(\"123\", \"containerId\")\n * ```\n */\ntoast.isActive = isToastActive;\n\n/**\n * Update a toast, see https://fkhadra.github.io/react-toastify/update-toast/ for more\n *\n * Example:\n * ```\n * // With a string\n * toast.update(toastId, {\n *    render: \"New content\",\n *    type: \"info\",\n * });\n *\n * // Or with a component\n * toast.update(toastId, {\n *    render: MyComponent\n * });\n *\n * // Or a function\n * toast.update(toastId, {\n *    render: () => <div>New content</div>\n * });\n *\n * // Apply a transition\n * toast.update(toastId, {\n *   render: \"New Content\",\n *   type: toast.TYPE.INFO,\n *   transition: Rotate\n * })\n * ```\n */\ntoast.update = <TData = unknown>(\n  toastId: Id,\n  options: UpdateOptions<TData> = {}\n) => {\n  const toast = getToast(toastId, options as ToastOptions);\n\n  if (toast) {\n    const { props: oldOptions, content: oldContent } = toast;\n\n    const nextOptions = {\n      delay: 100,\n      ...oldOptions,\n      ...options,\n      toastId: options.toastId || toastId,\n      updateId: genToastId()\n    } as ToastProps & UpdateOptions;\n\n    if (nextOptions.toastId !== toastId) nextOptions.staleId = toastId;\n\n    const content = nextOptions.render || oldContent;\n    delete nextOptions.render;\n\n    dispatchToast(content, nextOptions);\n  }\n};\n\n/**\n * Used for controlled progress bar. It will automatically close the notification.\n *\n * If you don't want your notification to be clsoed when the timer is done you should use `toast.update` instead as follow instead:\n *\n * ```\n * toast.update(id, {\n *    progress: null, // remove controlled progress bar\n *    render: \"ok\",\n *    type: \"success\",\n *    autoClose: 5000 // set autoClose to the desired value\n *   });\n * ```\n */\ntoast.done = (id: Id) => {\n  toast.update(id, {\n    progress: 1\n  });\n};\n\n/**\n * Subscribe to change when a toast is added, removed and updated\n *\n * Usage:\n * ```\n * const unsubscribe = toast.onChange((payload) => {\n *   switch (payload.status) {\n *   case \"added\":\n *     // new toast added\n *     break;\n *   case \"updated\":\n *     // toast updated\n *     break;\n *   case \"removed\":\n *     // toast has been removed\n *     break;\n *   }\n * })\n * ```\n */\ntoast.onChange = onChange;\n\n/**\n * Play a toast(s) timer progammatically\n *\n * Usage:\n *\n * - Play all toasts\n * ```\n * toast.play()\n * ```\n *\n * - Play all toasts for a given container\n * ```\n * toast.play({ containerId: \"123\" })\n * ```\n *\n * - Play toast that has a given id regardless the container\n * ```\n * toast.play({ id: \"123\" })\n * ```\n *\n * - Play toast that has a given id for a specific container\n * ```\n * toast.play({ id: \"123\", containerId: \"12\" })\n * ```\n */\ntoast.play = (opts?: IdOpts) => toggleToast(true, opts);\n\n/**\n * Pause a toast(s) timer progammatically\n *\n * Usage:\n *\n * - Pause all toasts\n * ```\n * toast.pause()\n * ```\n *\n * - Pause all toasts for a given container\n * ```\n * toast.pause({ containerId: \"123\" })\n * ```\n *\n * - Pause toast that has a given id regardless the container\n * ```\n * toast.pause({ id: \"123\" })\n * ```\n *\n * - Pause toast that has a given id for a specific container\n * ```\n * toast.pause({ id: \"123\", containerId: \"12\" })\n * ```\n */\ntoast.pause = (opts?: IdOpts) => toggleToast(false, opts);\n\nexport { toast };\n","import { useEffect, useLayoutEffect } from 'react';\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n","import React, { cloneElement, isValidElement } from 'react';\n\nimport { Theme, ToastProps, TypeOptions } from '../types';\nimport { Default, isFn } from '../utils';\n\n/**\n * Used when providing custom icon\n */\nexport interface IconProps {\n  theme: Theme;\n  type: TypeOptions;\n  isLoading?: boolean;\n}\n\nexport type BuiltInIconProps = React.SVGProps<SVGSVGElement> & IconProps;\n\nconst Svg: React.FC<BuiltInIconProps> = ({\n  theme,\n  type,\n  isLoading,\n  ...rest\n}) => (\n  <svg\n    viewBox=\"0 0 24 24\"\n    width=\"100%\"\n    height=\"100%\"\n    fill={\n      theme === 'colored'\n        ? 'currentColor'\n        : `var(--toastify-icon-color-${type})`\n    }\n    {...rest}\n  />\n);\n\nfunction Warning(props: BuiltInIconProps) {\n  return (\n    <Svg {...props}>\n      <path d=\"M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z\" />\n    </Svg>\n  );\n}\n\nfunction Info(props: BuiltInIconProps) {\n  return (\n    <Svg {...props}>\n      <path d=\"M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z\" />\n    </Svg>\n  );\n}\n\nfunction Success(props: BuiltInIconProps) {\n  return (\n    <Svg {...props}>\n      <path d=\"M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z\" />\n    </Svg>\n  );\n}\n\nfunction Error(props: BuiltInIconProps) {\n  return (\n    <Svg {...props}>\n      <path d=\"M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z\" />\n    </Svg>\n  );\n}\n\nfunction Spinner() {\n  return <div className={`${Default.CSS_NAMESPACE}__spinner`} />;\n}\n\nexport const Icons = {\n  info: Info,\n  warning: Warning,\n  success: Success,\n  error: Error,\n  spinner: Spinner\n};\n\nconst maybeIcon = (type: string): type is keyof typeof Icons => type in Icons;\n\nexport type IconParams = Pick<\n  ToastProps,\n  'theme' | 'icon' | 'type' | 'isLoading'\n>;\n\nexport function getIcon({ theme, type, isLoading, icon }: IconParams) {\n  let Icon: React.ReactNode = null;\n  const iconProps = { theme, type, isLoading };\n\n  if (icon === false) {\n    // hide\n  } else if (isFn(icon)) {\n    Icon = icon(iconProps);\n  } else if (isValidElement(icon)) {\n    Icon = cloneElement(icon, iconProps);\n  } else if (isLoading) {\n    Icon = Icons.spinner();\n  } else if (maybeIcon(type)) {\n    Icon = Icons[type](iconProps);\n  }\n\n  return Icon;\n}\n","import cx from 'clsx';\nimport React, { cloneElement, isValidElement, ReactNode } from 'react';\n\nimport { useToast } from '../hooks/useToast';\nimport { ToastProps } from '../types';\nimport { Default, isFn } from '../utils';\nimport { CloseButton } from './CloseButton';\nimport { ProgressBar } from './ProgressBar';\nimport { getIcon } from './Icons';\n\nexport const Toast: React.FC<ToastProps> = props => {\n  const {\n    isRunning,\n    preventExitTransition,\n    toastRef,\n    eventHandlers,\n    playToast\n  } = useToast(props);\n  const {\n    closeButton,\n    children,\n    autoClose,\n    onClick,\n    type,\n    hideProgressBar,\n    closeToast,\n    transition: Transition,\n    position,\n    className,\n    style,\n    bodyClassName,\n    bodyStyle,\n    progressClassName,\n    progressStyle,\n    updateId,\n    role,\n    progress,\n    rtl,\n    toastId,\n    deleteToast,\n    isIn,\n    isLoading,\n    closeOnClick,\n    theme\n  } = props;\n  const defaultClassName = cx(\n    `${Default.CSS_NAMESPACE}__toast`,\n    `${Default.CSS_NAMESPACE}__toast-theme--${theme}`,\n    `${Default.CSS_NAMESPACE}__toast--${type}`,\n    {\n      [`${Default.CSS_NAMESPACE}__toast--rtl`]: rtl\n    },\n    {\n      [`${Default.CSS_NAMESPACE}__toast--close-on-click`]: closeOnClick\n    }\n  );\n  const cssClasses = isFn(className)\n    ? className({\n        rtl,\n        position,\n        type,\n        defaultClassName\n      })\n    : cx(defaultClassName, className);\n  const icon = getIcon(props);\n  const isProgressControlled = !!progress || !autoClose;\n\n  const closeButtonProps = { closeToast, type, theme };\n  let Close: React.ReactNode = null;\n\n  if (closeButton === false) {\n    // hide\n  } else if (isFn(closeButton)) {\n    Close = closeButton(closeButtonProps);\n  } else if (isValidElement(closeButton)) {\n    Close = cloneElement(closeButton, closeButtonProps);\n  } else {\n    Close = CloseButton(closeButtonProps);\n  }\n\n  return (\n    <Transition\n      isIn={isIn}\n      done={deleteToast}\n      position={position}\n      preventExitTransition={preventExitTransition}\n      nodeRef={toastRef}\n      playToast={playToast}\n    >\n      <div\n        id={toastId as string}\n        onClick={onClick}\n        data-in={isIn}\n        className={cssClasses}\n        {...eventHandlers}\n        style={style}\n        ref={toastRef}\n      >\n        <div\n          {...(isIn && { role: role })}\n          className={\n            isFn(bodyClassName)\n              ? bodyClassName({ type })\n              : cx(`${Default.CSS_NAMESPACE}__toast-body`, bodyClassName)\n          }\n          style={bodyStyle}\n        >\n          {icon != null && (\n            <div\n              className={cx(`${Default.CSS_NAMESPACE}__toast-icon`, {\n                [`${Default.CSS_NAMESPACE}--animate-icon ${Default.CSS_NAMESPACE}__zoom-enter`]:\n                  !isLoading\n              })}\n            >\n              {icon}\n            </div>\n          )}\n          <div>{children as ReactNode}</div>\n        </div>\n        {Close}\n        <ProgressBar\n          {...(updateId && !isProgressControlled\n            ? { key: `pb-${updateId}` }\n            : {})}\n          rtl={rtl}\n          theme={theme}\n          delay={autoClose as number}\n          isRunning={isRunning}\n          isIn={isIn}\n          closeToast={closeToast}\n          hide={hideProgressBar}\n          type={type}\n          style={progressStyle}\n          className={progressClassName}\n          controlledProgress={isProgressControlled}\n          progress={progress || 0}\n        />\n      </div>\n    </Transition>\n  );\n};\n","import React from 'react';\nimport { Default } from '../utils';\nimport { Theme, TypeOptions } from '../types';\n\nexport interface CloseButtonProps {\n  closeToast: (e: React.MouseEvent<HTMLElement>) => void;\n  type: TypeOptions;\n  ariaLabel?: string;\n  theme: Theme;\n}\n\nexport function CloseButton({\n  closeToast,\n  theme,\n  ariaLabel = 'close'\n}: CloseButtonProps) {\n  return (\n    <button\n      className={`${Default.CSS_NAMESPACE}__close-button ${Default.CSS_NAMESPACE}__close-button--${theme}`}\n      type=\"button\"\n      onClick={e => {\n        e.stopPropagation();\n        closeToast(e);\n      }}\n      aria-label={ariaLabel}\n    >\n      <svg aria-hidden=\"true\" viewBox=\"0 0 14 16\">\n        <path\n          fillRule=\"evenodd\"\n          d=\"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z\"\n        />\n      </svg>\n    </button>\n  );\n}\n","import { Default, cssTransition } from '../utils';\n\nconst getConfig = (animationName: string, appendPosition = false) => ({\n  enter: `${Default.CSS_NAMESPACE}--animate ${Default.CSS_NAMESPACE}__${animationName}-enter`,\n  exit: `${Default.CSS_NAMESPACE}--animate ${Default.CSS_NAMESPACE}__${animationName}-exit`,\n  appendPosition\n});\n\nconst Bounce = cssTransition(getConfig('bounce', true));\n\nconst Slide = cssTransition(getConfig('slide', true));\n\nconst Zoom = cssTransition(getConfig('zoom'));\n\nconst Flip = cssTransition(getConfig('flip'));\n\nexport { Bounce, Slide, Zoom, Flip };\n","import cx from 'clsx';\nimport React, { useRef, useState } from 'react';\n\nimport { toast } from '../core';\nimport { useToastContainer } from '../hooks/useToastContainer';\nimport { useIsomorphicLayoutEffect } from '../hooks/useIsomorphicLayoutEffect';\nimport { ToastContainerProps, ToastPosition } from '../types';\nimport { Default, Direction, isFn, parseClassName } from '../utils';\nimport { Toast } from './Toast';\nimport { Bounce } from './Transitions';\n\nexport const defaultProps: ToastContainerProps = {\n  position: 'top-right',\n  transition: Bounce,\n  autoClose: 5000,\n  closeButton: true,\n  pauseOnHover: true,\n  pauseOnFocusLoss: true,\n  draggable: 'touch',\n  draggablePercent: Default.DRAGGABLE_PERCENT as number,\n  draggableDirection: Direction.X,\n  role: 'alert',\n  theme: 'light'\n};\n\nexport function ToastContainer(props: ToastContainerProps) {\n  let containerProps: ToastContainerProps = {\n    ...defaultProps,\n    ...props\n  };\n  const stacked = props.stacked;\n  const [collapsed, setIsCollapsed] = useState(true);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const { getToastToRender, isToastActive, count } =\n    useToastContainer(containerProps);\n  const { className, style, rtl, containerId } = containerProps;\n\n  function getClassName(position: ToastPosition) {\n    const defaultClassName = cx(\n      `${Default.CSS_NAMESPACE}__toast-container`,\n      `${Default.CSS_NAMESPACE}__toast-container--${position}`,\n      { [`${Default.CSS_NAMESPACE}__toast-container--rtl`]: rtl }\n    );\n    return isFn(className)\n      ? className({\n          position,\n          rtl,\n          defaultClassName\n        })\n      : cx(defaultClassName, parseClassName(className));\n  }\n\n  function collapseAll() {\n    if (stacked) {\n      setIsCollapsed(true);\n      toast.play();\n    }\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    if (stacked) {\n      const nodes = containerRef.current!.querySelectorAll('[data-in=\"true\"]');\n      const gap = 12;\n      const isTop = containerProps.position?.includes('top');\n      let usedHeight = 0;\n      let prevS = 0;\n\n      Array.from(nodes)\n        .reverse()\n        .forEach((n, i) => {\n          const node = n as HTMLElement;\n          node.classList.add(`${Default.CSS_NAMESPACE}__toast--stacked`);\n\n          if (i > 0) node.dataset.collapsed = `${collapsed}`;\n\n          if (!node.dataset.pos) node.dataset.pos = isTop ? 'top' : 'bot';\n\n          const y =\n            usedHeight * (collapsed ? 0.2 : 1) + (collapsed ? 0 : gap * i);\n\n          node.style.setProperty('--y', `${isTop ? y : y * -1}px`);\n          node.style.setProperty('--g', `${gap}`);\n          node.style.setProperty('--s', `${1 - (collapsed ? prevS : 0)}`);\n\n          usedHeight += node.offsetHeight;\n          prevS += 0.025;\n        });\n    }\n  }, [collapsed, count, stacked]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={Default.CSS_NAMESPACE as string}\n      id={containerId as string}\n      onMouseEnter={() => {\n        if (stacked) {\n          setIsCollapsed(false);\n          toast.pause();\n        }\n      }}\n      onMouseLeave={collapseAll}\n    >\n      {getToastToRender((position, toastList) => {\n        const containerStyle: React.CSSProperties = !toastList.length\n          ? { ...style, pointerEvents: 'none' }\n          : { ...style };\n\n        return (\n          <div\n            className={getClassName(position)}\n            style={containerStyle}\n            key={`container-${position}`}\n          >\n            {toastList.map(({ content, props: toastProps }) => {\n              return (\n                <Toast\n                  {...toastProps}\n                  stacked={stacked}\n                  collapseAll={collapseAll}\n                  isIn={isToastActive(\n                    toastProps.toastId,\n                    toastProps.containerId\n                  )}\n                  style={toastProps.style}\n                  key={`toast-${toastProps.key}`}\n                >\n                  {content}\n                </Toast>\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}